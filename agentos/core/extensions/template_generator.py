"""
Extension Template Generator

Generates DECLARATIVE extension templates with manifest.json, commands.yaml, install/plan.yaml, and docs.
Used by the Extension Wizard to provide a quick start for extension developers.

IMPORTANT: This generator produces DECLARATIVE-ONLY extensions per ADR-EXT-001.
No executable code (handlers.py, .py, .js, .sh) is generated.

Part of Task #13: Extension Template Wizard and Download
Fixed in Task #14: P0 Governance Violation - Remove Executable Code from Templates
"""

import io
import json
import logging
import zipfile
from pathlib import Path
from string import Template
from typing import Dict, List, Any, Optional

logger = logging.getLogger(__name__)

# Template for manifest.json (DECLARATIVE ONLY - ADR-EXT-001)
MANIFEST_TEMPLATE = Template('''{
  "id": "$extension_id",
  "name": "$extension_name",
  "version": "0.1.0",
  "description": "$description",
  "author": "$author",
  "license": "Apache-2.0",
  "entrypoint": null,
  "capabilities": $capabilities,
  "permissions_required": $permissions,
  "platforms": ["linux", "darwin", "win32"],
  "install": {
    "mode": "agentos_managed",
    "plan": "install/plan.yaml"
  },
  "docs": {
    "usage": "docs/USAGE.md"
  },
  "icon": "icon.svg"
}
''')

# Template for commands/commands.yaml (DECLARATIVE - ADR-EXT-001)
COMMANDS_YAML_TEMPLATE = Template('''# Commands Declaration for $extension_name
#
# This file declares all slash commands provided by this extension.
# All commands are executed by AgentOS Core - no custom code execution.
#
# Generated by AgentOS Extension Wizard

slash_commands:
$commands_list
''')

# Template for individual command in commands.yaml
COMMAND_ENTRY_TEMPLATE = Template('''  - name: "$capability_name"
    summary: "$capability_description"
    examples:
      - "$capability_name [arguments]"

    actions:
      - id: default
        description: "$capability_description"
        runner: exec.shell
        # TODO: Customize runner and actions based on your needs
        # Available runners: exec.shell, exec.powershell, analyze.text, etc.
''')

# Template for README.md (DECLARATIVE ONLY)
README_TEMPLATE = Template('''# $extension_name

$description

## Installation

1. Download the extension package ZIP file
2. Open AgentOS WebUI
3. Navigate to the Extensions page
4. Click "Upload Extension" and select the ZIP file
5. Wait for installation to complete
6. Enable the extension

## Capabilities

This extension provides the following capabilities:

$capabilities_list

## Permissions

This extension requires the following permissions:

$permissions_list

## Usage

$usage_instructions

## Architecture

This is a **Declarative-Only Extension** following AgentOS ADR-EXT-001.

### What This Means

- **No executable code**: This extension does not contain Python, JavaScript, or shell scripts
- **Core-controlled execution**: All commands are executed by AgentOS Core in a sandboxed environment
- **Security**: Cannot execute arbitrary code or bypass AgentOS security boundaries

See `docs/DESIGN.md` for detailed architecture documentation.

## Development

This extension was generated using the AgentOS Extension Wizard.

### File Structure

```
$extension_id/
├── manifest.json          # Extension metadata (DECLARATIVE)
├── commands/
│   └── commands.yaml     # Command declarations (DECLARATIVE)
├── install/
│   └── plan.yaml         # Installation plan (DECLARATIVE)
├── docs/
│   ├── USAGE.md          # User documentation
│   └── DESIGN.md         # Architecture documentation
├── icon.svg              # Extension icon
└── .gitignore            # Git ignore rules
```

### Modifying the Extension

1. Edit `commands/commands.yaml` to add/modify slash commands
2. Update `manifest.json` if you change capabilities or permissions
3. Modify `install/plan.yaml` to customize installation steps
4. Update documentation in `docs/USAGE.md` and `docs/DESIGN.md`

**IMPORTANT**: Do NOT add executable files (.py, .js, .sh, .exe) to the extension root. They will be rejected by the validator.

### Testing

Test your extension locally before distribution:

1. Validate: The template has been pre-validated with Extension Validator
2. Package as ZIP: `zip -r $extension_id.zip .` (from extension directory)
3. Install via WebUI
4. Test commands in AgentOS chat interface

## License

$license

## Author

$author

## Version

0.1.0
''')

# Template for USAGE.md
USAGE_TEMPLATE = Template('''# $extension_name Usage Guide

## Overview

$description

## Available Commands

$commands_documentation

## Examples

### Basic Usage

```
$example_usage
```

### Advanced Usage

```
# Combine with other AgentOS features
$advanced_example
```

## Permissions

This extension requires the following permissions:

$permissions_list

Grant these permissions during installation, or via Extensions Settings UI after installation.

## Troubleshooting

### Common Issues

**Issue**: Command not recognized
**Solution**: Ensure the extension is enabled in the Extensions page

**Issue**: Permission errors
**Solution**: Check that the extension has the required permissions granted

**Issue**: Command not working
**Solution**: Check the execution logs in the AgentOS WebUI for error details

## Architecture

This is a declarative-only extension. See `DESIGN.md` for architecture details.

## Support

For issues, questions, or contributions, contact: $author
''')

# Template for DESIGN.md (NEW - ADR-EXT-001)
DESIGN_TEMPLATE = Template('''# $extension_name - Architecture

## Declarative-Only Extension

This extension follows AgentOS ADR-EXT-001: **Declarative Extensions Only**.

### What This Means

- **No executable code**: This extension does not contain any Python, JavaScript, or shell scripts in the root directory.
- **Declarative configuration**: All functionality is defined through YAML configuration files.
- **Core-controlled execution**: All commands are executed by AgentOS Core in a sandboxed environment.

### File Structure

```
$extension_id/
├── manifest.json           # Extension metadata (DECLARATIVE)
├── commands/
│   └── commands.yaml      # Command declarations (DECLARATIVE)
├── install/
│   └── plan.yaml          # Installation steps (DECLARATIVE)
├── docs/
│   ├── USAGE.md           # User documentation
│   └── DESIGN.md          # This file
├── icon.svg               # Extension icon
└── .gitignore
```

### No handlers.py Required

Unlike traditional plugin systems, AgentOS extensions do NOT require a `handlers.py` or similar executable code file. All command execution is handled by:

1. **CapabilityRunner**: Executes commands declared in `commands.yaml`
2. **ExtensionInstallEngine**: Runs installation steps from `install/plan.yaml`
3. **Core Sandboxing**: Enforces security boundaries and permissions

### Security Benefits

- **No arbitrary code execution**: Extension cannot execute malicious code
- **Auditable**: All actions are logged and traceable
- **Permission-controlled**: Every operation requires explicit permission declaration
- **Sandboxed**: Execution is isolated to specific directories and environments

### How Commands Work

When a user invokes a command (e.g., `$example_command`):

1. AgentOS Core reads `commands/commands.yaml`
2. Core validates the command exists and permissions are granted
3. Core executes the declared actions using built-in runners
4. Results are returned to the user

No custom code from the extension is ever executed directly.

### Customization

To customize this extension:

1. **Add commands**: Edit `commands/commands.yaml` to add new slash commands
2. **Modify installation**: Edit `install/plan.yaml` to change installation steps
3. **Update metadata**: Edit `manifest.json` to change extension info
4. **Add documentation**: Update `docs/USAGE.md` with usage instructions

**DO NOT** add executable files (.py, .js, .sh, .exe) to the extension root - they will be rejected by the validator.

### References

- ADR-EXT-001: Declarative Extensions Only
- Extension Validator: `agentos.core.extensions.validator`
- Capability Runner: `agentos.core.capabilities.runner`
- Security Model: See ADR-EXT-001-ENFORCEMENT.md

## Version

Generated with AgentOS Extension Wizard v1.0 (Task #14: Declarative-Only)
''')

# Template for install/plan.yaml (DECLARATIVE - ADR-EXT-001)
INSTALL_PLAN_TEMPLATE = Template('''id: $extension_id
description: Installation plan for $extension_name

steps:
  - id: detect_platform
    type: detect.platform

  - id: show_install_info
    type: exec.shell
    requires_permissions: []
    command: |
      echo "Installing $extension_name..."
      echo "This is a declarative extension - no code execution"

  # TODO: Add your installation steps here
  # Example: Download and install a binary tool
  # - id: download_tool
  #   type: download.http
  #   url: "https://example.com/tool.zip"
  #   sha256: "expected-hash"
  #   requires_permissions: ["network"]
  #
  # - id: install_tool
  #   type: extract.zip
  #   source: "tool.zip"
  #   destination: ".agentos/tools/"
  #   requires_permissions: ["filesystem.write"]

  - id: finalize
    type: exec.shell
    command: |
      echo "$extension_name installed successfully!"
      echo "Use the slash commands declared in commands/commands.yaml"
''')

# Template for .gitignore
GITIGNORE_TEMPLATE = '''# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/
env/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Testing
.pytest_cache/
.coverage
htmlcov/
.tox/

# Extension specific
*.log
*.tmp
.env
secrets.json
'''

# Simple SVG icon template
ICON_TEMPLATE = Template('''<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <rect width="100" height="100" fill="#4F46E5" rx="15"/>
  <text x="50" y="65" font-family="Arial, sans-serif" font-size="50" font-weight="bold" fill="white" text-anchor="middle">$icon_letter</text>
</svg>
''')


class ExtensionTemplateGenerator:
    """Generator for extension templates"""

    def __init__(self):
        """Initialize the template generator"""
        pass

    def generate_template(
        self,
        extension_id: str,
        extension_name: str,
        description: str,
        author: str,
        capabilities: List[Dict[str, Any]],
        permissions: List[str]
    ) -> bytes:
        """
        Generate DECLARATIVE extension template as a ZIP file (ADR-EXT-001)

        This generator produces declarative-only extensions. No executable code
        (handlers.py, .py, .js, .sh) is generated.

        Args:
            extension_id: Extension ID (e.g., 'tools.myext')
            extension_name: Human-readable name
            description: Extension description
            author: Author name
            capabilities: List of capability configurations
            permissions: List of required permissions

        Returns:
            ZIP file content as bytes (validated declarative template)
        """
        # Validate extension_id format
        self._validate_extension_id(extension_id)

        # Create in-memory ZIP file
        zip_buffer = io.BytesIO()

        # The ZIP must have exactly one top-level directory (validator requirement)
        # Use extension_id as the directory name
        root_dir = extension_id

        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            # Generate manifest.json (DECLARATIVE)
            manifest_content = self._generate_manifest(
                extension_id, extension_name, description, author,
                capabilities, permissions
            )
            zip_file.writestr(f'{root_dir}/manifest.json', manifest_content)

            # Generate commands/commands.yaml (DECLARATIVE - NEW)
            commands_content = self._generate_commands_yaml(
                extension_name, capabilities
            )
            zip_file.writestr(f'{root_dir}/commands/commands.yaml', commands_content)

            # Generate install/plan.yaml (DECLARATIVE)
            plan_content = self._generate_install_plan(
                extension_id, extension_name, permissions
            )
            zip_file.writestr(f'{root_dir}/install/plan.yaml', plan_content)

            # Generate README.md
            readme_content = self._generate_readme(
                extension_id, extension_name, description, author,
                capabilities, permissions
            )
            zip_file.writestr(f'{root_dir}/README.md', readme_content)

            # Generate docs/USAGE.md
            usage_content = self._generate_usage_doc(
                extension_name, description, author, capabilities, permissions
            )
            zip_file.writestr(f'{root_dir}/docs/USAGE.md', usage_content)

            # Generate docs/DESIGN.md (NEW - Architecture documentation)
            design_content = self._generate_design_doc(
                extension_id, extension_name, capabilities
            )
            zip_file.writestr(f'{root_dir}/docs/DESIGN.md', design_content)

            # Generate .gitignore
            zip_file.writestr(f'{root_dir}/.gitignore', GITIGNORE_TEMPLATE)

            # Generate icon.svg
            icon_content = self._generate_icon(extension_name)
            zip_file.writestr(f'{root_dir}/icon.svg', icon_content)

        zip_buffer.seek(0)
        zip_content = zip_buffer.getvalue()

        # CRITICAL: Validate the generated template with Extension Validator
        # This ensures we're producing compliant declarative-only extensions
        self._validate_generated_template(zip_content, extension_id)

        return zip_content

    def _validate_extension_id(self, extension_id: str) -> None:
        """Validate extension ID format"""
        import re
        pattern = r'^[a-z0-9]+\.[a-z0-9]+$'
        if not re.match(pattern, extension_id):
            raise ValueError(
                f"Invalid extension ID '{extension_id}'. "
                "Format must be 'namespace.name' (lowercase alphanumeric only, e.g., 'tools.myext')"
            )

    def _generate_manifest(
        self,
        extension_id: str,
        extension_name: str,
        description: str,
        author: str,
        capabilities: List[Dict[str, Any]],
        permissions: List[str]
    ) -> str:
        """Generate manifest.json content"""
        # Format capabilities for JSON
        capabilities_json = json.dumps([
            {
                "type": cap["type"],
                "name": cap["name"],
                "description": cap["description"],
                "config": cap.get("config", {})
            }
            for cap in capabilities
        ], indent=4)

        # Format permissions for JSON
        permissions_json = json.dumps(permissions, indent=4)

        return MANIFEST_TEMPLATE.substitute(
            extension_id=extension_id,
            extension_name=extension_name,
            description=description,
            author=author,
            capabilities=capabilities_json,
            permissions=permissions_json
        )

    def _generate_commands_yaml(
        self,
        extension_name: str,
        capabilities: List[Dict[str, Any]]
    ) -> str:
        """Generate commands/commands.yaml content (DECLARATIVE)"""
        # Generate command entries for slash commands only
        command_entries = []

        for cap in capabilities:
            if cap["type"] == "slash_command":
                command_entry = COMMAND_ENTRY_TEMPLATE.substitute(
                    capability_name=cap["name"],
                    capability_description=cap["description"]
                )
                command_entries.append(command_entry)

        # If no slash commands, create a placeholder
        if not command_entries:
            command_entries.append('''  # No slash commands defined
  # Add your commands here following this format:
  # - name: "/mycommand"
  #   summary: "Description of what the command does"
  #   examples:
  #     - "/mycommand arg1 arg2"
  #   actions:
  #     - id: default
  #       description: "Action description"
  #       runner: exec.shell''')

        return COMMANDS_YAML_TEMPLATE.substitute(
            extension_name=extension_name,
            commands_list='\n'.join(command_entries)
        )

    def _validate_generated_template(self, zip_content: bytes, extension_id: str) -> None:
        """
        Validate the generated template using Extension Validator (CRITICAL)

        This ensures the template generator produces compliant declarative-only extensions.
        Performs basic structural validation to ensure:
        1. Valid ZIP structure
        2. No executable files in root
        3. Required declarative files present

        Args:
            zip_content: The generated ZIP file content
            extension_id: Extension ID for error messages

        Raises:
            ValueError: If the generated template fails basic validation
        """
        import tempfile
        from pathlib import Path
        import zipfile as zf

        # Write to temporary file for validation
        with tempfile.NamedTemporaryFile(suffix='.zip', delete=False) as tmp_file:
            tmp_file.write(zip_content)
            tmp_path = Path(tmp_file.name)

        try:
            # Basic validation: Check ZIP structure
            with zf.ZipFile(tmp_path, 'r') as zip_file:
                file_list = zip_file.namelist()

                # Check for forbidden executable files in root
                forbidden_extensions = ['.py', '.js', '.sh', '.exe', '.bat', '.cmd', '.ps1']
                root_files = [f for f in file_list if f.count('/') == 1 and not f.endswith('/')]

                for file_path in root_files:
                    if any(file_path.lower().endswith(ext) for ext in forbidden_extensions):
                        raise ValueError(
                            f"Template generator produced INVALID extension: "
                            f"Found forbidden executable file in root: {file_path}. "
                            f"This violates ADR-EXT-001 (Task #14). "
                            f"Extension: {extension_id}"
                        )

                # Check for required declarative files
                required_files = [
                    'manifest.json',
                    'commands/commands.yaml',
                    'install/plan.yaml',
                    'docs/USAGE.md'
                ]

                top_dir = file_list[0].split('/')[0] if file_list else extension_id
                for required in required_files:
                    full_path = f"{top_dir}/{required}"
                    if full_path not in file_list:
                        raise ValueError(
                            f"Template generator produced INVALID extension: "
                            f"Missing required file: {required}. "
                            f"Extension: {extension_id}"
                        )

            logger.info(
                f"Template generator self-check PASSED: {extension_id} "
                f"(validated as declarative-only, no executable code)"
            )

        except zf.BadZipFile as e:
            raise ValueError(
                f"Template generator produced INVALID ZIP: {e}. "
                f"Extension: {extension_id}"
            )
        finally:
            # Clean up temp file
            tmp_path.unlink(missing_ok=True)

    def _generate_readme(
        self,
        extension_id: str,
        extension_name: str,
        description: str,
        author: str,
        capabilities: List[Dict[str, Any]],
        permissions: List[str]
    ) -> str:
        """Generate README.md content"""
        # Format capabilities list
        capabilities_list = '\n'.join([
            f"- **{cap['name']}** ({cap['type']}): {cap['description']}"
            for cap in capabilities
        ])

        # Format permissions list
        permissions_list = '\n'.join([
            f"- `{perm}`"
            for perm in permissions
        ]) if permissions else "- None"

        # Generate usage instructions based on capability types
        usage_instructions = self._generate_usage_instructions(capabilities)

        return README_TEMPLATE.substitute(
            extension_id=extension_id,
            extension_name=extension_name,
            description=description,
            author=author,
            license="Apache-2.0",
            capabilities_list=capabilities_list,
            permissions_list=permissions_list,
            usage_instructions=usage_instructions
        )

    def _generate_usage_instructions(
        self,
        capabilities: List[Dict[str, Any]]
    ) -> str:
        """Generate usage instructions based on capabilities"""
        instructions = []

        for cap in capabilities:
            if cap["type"] == "slash_command":
                instructions.append(
                    f"### Using {cap['name']}\n\n"
                    f"In the AgentOS chat interface, type:\n\n"
                    f"```\n{cap['name']} [arguments]\n```\n"
                )

        if not instructions:
            return "Refer to the documentation for usage details."

        return '\n'.join(instructions)

    def _generate_install_plan(
        self,
        extension_id: str,
        extension_name: str,
        permissions: List[str]
    ) -> str:
        """Generate install/plan.yaml content (DECLARATIVE)"""
        return INSTALL_PLAN_TEMPLATE.substitute(
            extension_id=extension_id,
            extension_name=extension_name
        )

    def _generate_usage_doc(
        self,
        extension_name: str,
        description: str,
        author: str,
        capabilities: List[Dict[str, Any]],
        permissions: List[str]
    ) -> str:
        """Generate docs/USAGE.md content"""
        # Generate commands documentation
        commands_doc = []
        for cap in capabilities:
            commands_doc.append(
                f"### {cap['name']}\n\n"
                f"**Type**: {cap['type']}\n\n"
                f"**Description**: {cap['description']}\n\n"
                f"**Usage**:\n```\n{cap['name']}\n```\n"
            )

        commands_documentation = '\n'.join(commands_doc) if commands_doc else "No commands defined yet."

        # Generate example usage
        example_usage = capabilities[0]['name'] if capabilities else "# No capabilities defined"
        advanced_example = f"{example_usage} # with additional parameters"

        # Format permissions list
        permissions_list = '\n'.join([
            f"- `{perm}`"
            for perm in permissions
        ]) if permissions else "- None"

        return USAGE_TEMPLATE.substitute(
            extension_name=extension_name,
            description=description,
            author=author,
            commands_documentation=commands_documentation,
            example_usage=example_usage,
            advanced_example=advanced_example,
            permissions_list=permissions_list
        )

    def _generate_design_doc(
        self,
        extension_id: str,
        extension_name: str,
        capabilities: List[Dict[str, Any]]
    ) -> str:
        """Generate docs/DESIGN.md content (NEW - Architecture documentation)"""
        # Generate example command for documentation
        example_command = capabilities[0]['name'] if capabilities else "/example"

        return DESIGN_TEMPLATE.substitute(
            extension_id=extension_id,
            extension_name=extension_name,
            example_command=example_command
        )

    def _generate_icon(self, extension_name: str) -> str:
        """Generate a simple SVG icon"""
        # Use first letter of extension name
        icon_letter = extension_name[0].upper() if extension_name else 'E'
        return ICON_TEMPLATE.substitute(icon_letter=icon_letter)


def create_template(
    extension_id: str,
    extension_name: str,
    description: str,
    author: str,
    capabilities: List[Dict[str, Any]],
    permissions: List[str]
) -> bytes:
    """
    Convenience function to create an extension template

    Args:
        extension_id: Extension ID (e.g., 'tools.myext')
        extension_name: Human-readable name
        description: Extension description
        author: Author name
        capabilities: List of capability configurations
        permissions: List of required permissions

    Returns:
        ZIP file content as bytes
    """
    generator = ExtensionTemplateGenerator()
    return generator.generate_template(
        extension_id=extension_id,
        extension_name=extension_name,
        description=description,
        author=author,
        capabilities=capabilities,
        permissions=permissions
    )

"""
Tasks API - Task querying and routing

POST /api/tasks - Create a new task (session_id auto-generated)
GET /api/tasks - List tasks (with filters)
GET /api/tasks/{id} - Get task details
GET /api/tasks/{id}/route - Get task routing plan
POST /api/tasks/{id}/route - Override task routing
"""

from fastapi import APIRouter, Query, HTTPException, Request
from pydantic import BaseModel, Field, field_validator
from typing import List, Optional, Dict, Any
import json
import logging
import os

from agentos.core.task import TaskManager, Task
from agentos.core.task.service import TaskService
from agentos.core.task.routing_service import TaskRoutingService
from agentos.router.models import RoutePlan
from slowapi import Limiter
from slowapi.util import get_remote_address

# Import custom rate limit key function (L-1: Test bypass)
from agentos.webui.middleware.rate_limit import get_rate_limit_key

logger = logging.getLogger(__name__)

router = APIRouter()

# Rate limit configuration from environment variables
RATE_LIMIT_PER_MINUTE = os.getenv("RATE_LIMIT_PER_MINUTE", "10")
RATE_LIMIT_PER_HOUR = os.getenv("RATE_LIMIT_PER_HOUR", "100")

# Create limiter instance for this module with test bypass support (L-1)
limiter = Limiter(key_func=get_rate_limit_key)


class TaskCreateRequest(BaseModel):
    """Request model for creating a new task"""
    title: str = Field(..., min_length=1, max_length=500, description="Task title (1-500 characters)")
    session_id: Optional[str] = Field(
        None,
        description="Session ID (auto-generated by backend, client should NOT provide this field)"
    )
    project_id: Optional[str] = Field(None, description="Optional project ID to associate task with")
    created_by: Optional[str] = Field(None, description="Optional creator identifier")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Optional metadata")

    @field_validator('title')
    @classmethod
    def validate_title(cls, v: str) -> str:
        """Validate title is not empty after stripping whitespace"""
        if not v.strip():
            raise ValueError("Title cannot be empty or contain only whitespace")
        return v.strip()


class TaskSummary(BaseModel):
    """Task summary for list view"""
    task_id: str
    title: str
    status: str
    session_id: Optional[str] = None
    project_id: Optional[str] = None
    created_at: str
    updated_at: Optional[str] = None
    metadata: Dict[str, Any] = {}


class TaskResponse(BaseModel):
    """Task creation response (Step 2: C-1 Fix Validation)"""
    task_id: str = Field(..., description="Task ID")
    title: str = Field(..., description="Task title")
    status: str = Field(..., description="Task status")
    session_id: str = Field(..., description="Associated session ID (auto-generated)")
    project_id: Optional[str] = Field(None, description="Project ID")
    created_at: Optional[str] = Field(None, description="Creation timestamp")
    updated_at: Optional[str] = Field(None, description="Last update timestamp")
    created_by: Optional[str] = Field(None, description="Creator identifier")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Task metadata")
    spec_frozen: int = Field(0, description="Spec frozen flag (0=unfrozen, 1=frozen)")

    # Router fields (optional)
    route_plan_json: Optional[str] = Field(None, description="JSON serialized RoutePlan")
    requirements_json: Optional[str] = Field(None, description="JSON serialized TaskRequirements")
    selected_instance_id: Optional[str] = Field(None, description="Selected provider instance ID")
    router_version: Optional[str] = Field(None, description="Router version")

    # v0.4 fields (optional)
    repo_id: Optional[str] = Field(None, description="Repository ID")
    workdir: Optional[str] = Field(None, description="Working directory")

    class Config:
        from_attributes = True  # Allow conversion from Task dataclass


@router.post("/create_and_start")
@limiter.limit(f"{RATE_LIMIT_PER_MINUTE}/minute")
@limiter.limit(f"{RATE_LIMIT_PER_HOUR}/hour")
async def create_task_and_start(request: Request, task_request: TaskCreateRequest) -> Dict[str, Any]:
    """
    Create a new task and immediately start execution (Task #1: PR-A)

    This endpoint combines task creation with automatic approval, queuing, and runner launch.
    Designed for event-driven scenarios (e.g., chat commands) that require immediate execution.

    Flow:
        1. Create task in DRAFT state
        2. Auto-approve (DRAFT -> APPROVED)
        3. Auto-queue (APPROVED -> QUEUED)
        4. Launch runner in background (QUEUED -> RUNNING)

    Rate Limits:
        - 10 requests per minute (configurable via RATE_LIMIT_PER_MINUTE env var)
        - 100 requests per hour (configurable via RATE_LIMIT_PER_HOUR env var)

    Args:
        request: FastAPI Request object (required for rate limiting)
        task_request: TaskCreateRequest with task details

    Returns:
        Dictionary with created task and launch status:
        {
            "task": Task object,
            "launched": boolean,
            "message": string
        }

    Example:
        POST /api/tasks/create_and_start
        {
            "title": "Implement user authentication",
            "created_by": "chat@example.com",
            "metadata": {"priority": "high", "source": "chat"}
        }

    Raises:
        HTTPException: 400 for validation errors, 429 for rate limit exceeded, 500 for server errors
    """
    try:
        # 1. Create task in DRAFT state
        task_service = TaskService()
        task = task_service.create_draft_task(
            title=task_request.title,
            session_id=task_request.session_id,
            project_id=task_request.project_id,
            created_by=task_request.created_by,
            metadata=task_request.metadata,
        )

        logger.info(f"Created task {task.task_id} for immediate execution")

        # 2. Launch task (approve, queue, and start runner)
        from agentos.core.runner.launcher import launch_task_async

        actor = task_request.created_by or "api_launcher"
        success = launch_task_async(task.task_id, actor=actor)

        if success:
            return {
                "task": task,
                "launched": True,
                "message": f"Task {task.task_id} created and launched successfully"
            }
        else:
            logger.warning(f"Task {task.task_id} created but failed to launch")
            return {
                "task": task,
                "launched": False,
                "message": f"Task {task.task_id} created but failed to launch automatically"
            }

    except ValueError as e:
        # Validation errors (e.g., invalid title)
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        # Unexpected errors
        logger.error(f"Failed to create and start task: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Failed to create and start task: {str(e)}"
        )


@router.post("", response_model=TaskResponse)
@limiter.limit(f"{RATE_LIMIT_PER_MINUTE}/minute")
@limiter.limit(f"{RATE_LIMIT_PER_HOUR}/hour")
async def create_task(request: Request, task_request: TaskCreateRequest) -> TaskResponse:
    """
    Create a new task in DRAFT state

    Rate Limits:
        - 10 requests per minute (configurable via RATE_LIMIT_PER_MINUTE env var)
        - 100 requests per hour (configurable via RATE_LIMIT_PER_HOUR env var)

    Args:
        request: FastAPI Request object (required for rate limiting)
        task_request: TaskCreateRequest with task details

    Returns:
        TaskResponse with created task details including auto-generated session_id

    Notes:
        - session_id is automatically generated by the backend in format: "auto_{task_id}_{timestamp}"
        - Clients should NOT provide session_id in the request body
        - Providing a custom session_id may cause FOREIGN KEY constraint errors
        - Only title is required; created_by and metadata are optional
        - Response ALWAYS includes session_id (Step 2: C-1 Fix Validation)

    Example:
        POST /api/tasks
        {
            "title": "Implement user authentication",
            "created_by": "user@example.com",
            "metadata": {"priority": "high"}
        }

        Response:
        {
            "task_id": "task_01HY6XA...",
            "title": "Implement user authentication",
            "status": "draft",
            "session_id": "auto_task_01HY6XA..._1706789123",  # ✅ Always present
            "created_at": "2024-02-01T10:15:23Z",
            ...
        }

    Raises:
        HTTPException: 400 for validation errors, 429 for rate limit exceeded, 500 for server errors
    """
    try:
        # Note: session_id is auto-generated by TaskService.create_draft_task()
        # Format: "auto_{task_id}_{timestamp}"
        # DO NOT accept session_id from client request
        task_service = TaskService()
        task = task_service.create_draft_task(
            title=task_request.title,
            session_id=task_request.session_id,
            project_id=task_request.project_id,
            created_by=task_request.created_by,
            metadata=task_request.metadata,
        )

        # Convert Task to TaskResponse (ensures session_id is included)
        return TaskResponse(
            task_id=task.task_id,
            title=task.title,
            status=task.status,
            session_id=task.session_id or "",  # ✅ Ensure non-null
            project_id=task.project_id,
            created_at=task.created_at,
            updated_at=task.updated_at,
            created_by=task.created_by,
            metadata=task.metadata,
            spec_frozen=task.spec_frozen,
            route_plan_json=task.route_plan_json,
            requirements_json=task.requirements_json,
            selected_instance_id=task.selected_instance_id,
            router_version=task.router_version,
            repo_id=task.repo_id,
            workdir=task.workdir,
        )

    except ValueError as e:
        # Validation errors (e.g., invalid title)
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        # Unexpected errors
        logger.error(f"Failed to create task: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Failed to create task: {str(e)}"
        )


@router.get("")
async def list_tasks(
    project_id: Optional[str] = Query(None, description="Filter by project ID"),
    session_id: Optional[str] = Query(None, description="Filter by session ID"),
    status: Optional[str] = Query(None, description="Filter by status"),
    limit: int = Query(50, ge=1, le=200, description="Max results"),
    offset: int = Query(0, ge=0, description="Offset for pagination"),
    sort: str = Query("updated_at:desc", description="Sort order (field:asc|desc)")
) -> Dict[str, Any]:
    """
    List tasks with optional filters

    Args:
        project_id: Filter by project ID (uses idx_tasks_project_id index)
        session_id: Filter by session ID
        status: Filter by status
        limit: Maximum number of results
        offset: Offset for pagination
        sort: Sort order (e.g., "updated_at:desc", "created_at:desc")

    Returns:
        Dictionary with tasks list and metadata
    """
    try:
        from agentos.store import get_db

        conn = get_db()
        cursor = conn.cursor()

        # Build query with filters
        query = "SELECT * FROM tasks WHERE 1=1"
        params = []

        # Apply project_id filter (uses index: idx_tasks_project_id)
        if project_id:
            query += " AND project_id = ?"
            params.append(project_id)

        # Apply session_id filter
        if session_id:
            query += " AND session_id = ?"
            params.append(session_id)

        # Apply status filter
        if status:
            query += " AND status = ?"
            params.append(status)

        # Parse sort parameter
        sort_field, sort_order = "updated_at", "DESC"
        if sort and ":" in sort:
            field, order = sort.split(":", 1)
            if field in ("created_at", "updated_at", "status", "title"):
                sort_field = field
                sort_order = order.upper() if order.upper() in ("ASC", "DESC") else "DESC"

        # Add ORDER BY
        query += f" ORDER BY {sort_field} {sort_order}"

        # Add LIMIT and OFFSET
        query += " LIMIT ? OFFSET ?"
        params.append(limit)
        params.append(offset)

        # Execute query
        cursor.execute(query, params)
        rows = cursor.fetchall()

        # Convert to TaskSummary objects
        summaries = []
        for row in rows:
            row_dict = dict(row)
            # Parse metadata JSON
            metadata_str = row_dict.get("metadata")
            metadata = json.loads(metadata_str) if metadata_str else {}

            summaries.append(TaskSummary(
                task_id=row_dict["task_id"],
                title=row_dict["title"],
                status=row_dict["status"],
                session_id=row_dict.get("session_id"),
                project_id=row_dict.get("project_id"),
                created_at=row_dict.get("created_at", ""),
                updated_at=row_dict.get("updated_at"),
                metadata=metadata,
            ))

        # Get total count (for pagination)
        count_query = "SELECT COUNT(*) FROM tasks WHERE 1=1"
        count_params = []
        if project_id:
            count_query += " AND project_id = ?"
            count_params.append(project_id)
        if session_id:
            count_query += " AND session_id = ?"
            count_params.append(session_id)
        if status:
            count_query += " AND status = ?"
            count_params.append(status)

        cursor.execute(count_query, count_params)
        total = cursor.fetchone()[0]

        return {
            "tasks": summaries,
            "total": total,
            "limit": limit,
            "offset": offset,
        }

    except Exception as e:
        logger.error(f"Failed to list tasks: {str(e)}", exc_info=True)
        return {
            "tasks": [],
            "total": 0,
            "limit": limit,
            "offset": offset,
        }


@router.get("/{task_id}")
async def get_task(task_id: str) -> Task:
    """
    Get task details by ID

    Args:
        task_id: Task ID

    Returns:
        Task details
    """
    manager = TaskManager()
    task = manager.get_task(task_id)

    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    return task


# Routing endpoints (PR-2: Chat→Task Router Integration)


class RoutePlanResponse(BaseModel):
    """Route plan response"""
    task_id: str
    selected: str
    fallback: List[str]
    scores: Dict[str, float]
    reasons: List[str]
    router_version: str
    timestamp: str
    requirements: Optional[Dict[str, Any]] = None


class RouteOverrideRequest(BaseModel):
    """Route override request"""
    instance_id: str


# Batch creation models
class TaskBatchItem(BaseModel):
    """Single task item in batch creation request"""
    title: str = Field(..., min_length=1, max_length=500, description="Task title")
    project_id: Optional[str] = Field(None, description="Optional project ID")
    created_by: Optional[str] = Field(None, description="Optional creator identifier")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Optional metadata")

    @field_validator('title')
    @classmethod
    def validate_title(cls, v: str) -> str:
        """Validate title is not empty after stripping whitespace"""
        if not v.strip():
            raise ValueError("Title cannot be empty or contain only whitespace")
        return v.strip()


class TaskBatchCreateRequest(BaseModel):
    """Batch task creation request"""
    tasks: List[TaskBatchItem] = Field(..., min_length=1, max_length=100, description="List of tasks to create")

    @field_validator('tasks')
    @classmethod
    def validate_batch_size(cls, v):
        if len(v) > 100:
            raise ValueError("Maximum batch size is 100 tasks")
        return v


class TaskBatchCreateResponse(BaseModel):
    """Batch task creation response"""
    total: int = Field(..., description="Total number of tasks in request")
    successful: int = Field(..., description="Number of successfully created tasks")
    failed: int = Field(..., description="Number of failed tasks")
    tasks: List[Task] = Field(..., description="Successfully created tasks")
    errors: List[Dict[str, Any]] = Field(..., description="Errors for failed tasks")


@router.get("/{task_id}/route")
async def get_task_route(task_id: str) -> RoutePlanResponse:
    """
    Get routing plan for a task

    Args:
        task_id: Task ID

    Returns:
        RoutePlanResponse with routing details
    """
    manager = TaskManager()
    task = manager.get_task(task_id)

    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    if not task.route_plan_json:
        raise HTTPException(status_code=404, detail="Task has no routing information")

    try:
        plan_dict = json.loads(task.route_plan_json)
        plan = RoutePlan.from_dict(plan_dict)

        return RoutePlanResponse(
            task_id=plan.task_id,
            selected=plan.selected,
            fallback=plan.fallback,
            scores=plan.scores,
            reasons=plan.reasons,
            router_version=plan.router_version,
            timestamp=plan.timestamp or "",
            requirements=plan.requirements.to_dict() if plan.requirements else None,
        )
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to parse routing information: {str(e)}"
        )


@router.post("/{task_id}/route")
async def override_task_route(
    task_id: str,
    request: RouteOverrideRequest,
) -> RoutePlanResponse:
    """
    Override task routing (manual instance selection)

    Args:
        task_id: Task ID
        request: RouteOverrideRequest with new instance_id

    Returns:
        Updated RoutePlanResponse
    """
    try:
        routing_service = TaskRoutingService()
        new_plan = routing_service.override_route(task_id, request.instance_id)

        return RoutePlanResponse(
            task_id=new_plan.task_id,
            selected=new_plan.selected,
            fallback=new_plan.fallback,
            scores=new_plan.scores,
            reasons=new_plan.reasons,
            router_version=new_plan.router_version,
            timestamp=new_plan.timestamp or "",
            requirements=new_plan.requirements.to_dict() if new_plan.requirements else None,
        )
    except RuntimeError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to override route: {str(e)}"
        )


# Batch creation endpoint
@router.post("/batch")
@limiter.limit(f"{RATE_LIMIT_PER_MINUTE}/minute")
async def create_tasks_batch(
    request: Request,
    batch_request: TaskBatchCreateRequest
) -> TaskBatchCreateResponse:
    """
    Batch create tasks in DRAFT state

    Rate Limits:
        - Same as single task creation (configurable via env vars)

    Args:
        request: FastAPI Request object (required for rate limiting)
        batch_request: TaskBatchCreateRequest with list of tasks

    Returns:
        TaskBatchCreateResponse with success/failure statistics

    Notes:
        - Maximum batch size: 100 tasks
        - Operates in non-atomic mode (partial success allowed)
        - Failed tasks will be reported in errors list with details
        - Rate limit applies per batch request, not per task
        - Each task gets auto-generated session_id in format: "auto_{task_id}_{timestamp}"

    Example:
        POST /api/tasks/batch
        {
            "tasks": [
                {"title": "Task 1", "metadata": {"priority": "high"}},
                {"title": "Task 2", "created_by": "user@example.com"}
            ]
        }

    Raises:
        HTTPException: 400 for validation errors, 429 for rate limit exceeded, 500 for server errors
    """
    try:
        task_service = TaskService()

        # Convert batch items to dict format for service layer
        tasks_data = [
            {
                'title': item.title,
                'project_id': item.project_id,
                'created_by': item.created_by,
                'metadata': item.metadata or {}
            }
            for item in batch_request.tasks
        ]

        # Create tasks one by one (non-atomic mode allows partial success)
        successful_tasks = []
        failed_tasks = []

        for idx, task_data in enumerate(tasks_data):
            try:
                task = task_service.create_draft_task(
                    title=task_data['title'],
                    project_id=task_data.get('project_id'),
                    created_by=task_data.get('created_by'),
                    metadata=task_data.get('metadata')
                )
                successful_tasks.append(task)
            except Exception as e:
                logger.error(f"Failed to create task {idx} in batch: {e}", exc_info=True)
                failed_tasks.append({
                    'index': idx,
                    'title': task_data['title'],
                    'error': str(e)
                })

        return TaskBatchCreateResponse(
            total=len(batch_request.tasks),
            successful=len(successful_tasks),
            failed=len(failed_tasks),
            tasks=successful_tasks,
            errors=failed_tasks
        )

    except ValueError as e:
        # Validation errors
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        # Unexpected errors
        logger.error(f"Failed to process batch creation: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Failed to process batch creation: {str(e)}"
        )

"""
Task Event Service - Event insertion with strict seq generation

Provides event emission API for Runner UI visualization system.
Ensures strict monotonic sequence numbers per task for ordered event streaming.
"""

import json
import logging
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any, List

from agentos.store import get_writer

logger = logging.getLogger(__name__)


@dataclass
class TaskEvent:
    """Task event model for UI visualization"""

    event_id: Optional[int] = None  # Auto-generated by DB
    task_id: str = ""
    event_type: str = ""
    phase: Optional[str] = None
    actor: str = ""
    span_id: str = ""
    parent_span_id: Optional[str] = None
    seq: int = 0
    payload: Dict[str, Any] = field(default_factory=dict)
    created_at: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return {
            "event_id": self.event_id,
            "task_id": self.task_id,
            "event_type": self.event_type,
            "phase": self.phase,
            "actor": self.actor,
            "span_id": self.span_id,
            "parent_span_id": self.parent_span_id,
            "seq": self.seq,
            "payload": self.payload,
            "created_at": self.created_at,
        }

    @classmethod
    def from_row(cls, row: Any) -> "TaskEvent":
        """Create from database row"""
        return cls(
            event_id=row["event_id"],
            task_id=row["task_id"],
            event_type=row["event_type"],
            phase=row["phase"],
            actor=row["actor"],
            span_id=row["span_id"],
            parent_span_id=row["parent_span_id"],
            seq=row["seq"],
            payload=json.loads(row["payload"]) if row["payload"] else {},
            created_at=row["created_at"],
        )


class TaskEventService:
    """
    Service for task event management

    Handles event insertion with strict monotonic sequence generation.
    Uses SQLiteWriter for concurrent write serialization.
    """

    def __init__(self):
        self.writer = get_writer()

    def emit_event(
        self,
        task_id: str,
        event_type: str,
        actor: str,
        span_id: str,
        phase: Optional[str] = None,
        parent_span_id: Optional[str] = None,
        payload: Optional[Dict[str, Any]] = None,
        timeout: float = 10.0,
    ) -> TaskEvent:
        """
        Emit a task event with strict seq generation

        This method generates the next sequence number atomically and inserts
        the event in a single transaction via SQLiteWriter.

        Args:
            task_id: Task ID
            event_type: Event type (e.g., 'runner_spawn', 'phase_enter')
            actor: Actor (e.g., 'runner', 'supervisor', 'worker')
            span_id: Span ID (unique identifier for this execution context)
            phase: Optional phase (e.g., 'planning', 'executing')
            parent_span_id: Optional parent span ID (for hierarchy)
            payload: Optional payload dictionary
            timeout: Write operation timeout (default: 10.0 seconds)

        Returns:
            TaskEvent object with assigned seq and event_id

        Raises:
            RuntimeError: If event insertion fails
        """
        if not task_id:
            raise ValueError("task_id is required")
        if not event_type:
            raise ValueError("event_type is required")
        if not actor:
            raise ValueError("actor is required")
        if not span_id:
            raise ValueError("span_id is required")

        payload = payload or {}
        payload_json = json.dumps(payload)

        # Variables to capture results from transaction
        result = {"event_id": None, "seq": None, "created_at": None}

        def _insert_event(conn):
            """Transaction: Generate seq + insert event"""
            cursor = conn.cursor()

            # Step 1: Get next seq (initialize if not exists)
            cursor.execute(
                """
                INSERT INTO task_event_seq_counters (task_id, next_seq)
                VALUES (?, 1)
                ON CONFLICT(task_id) DO NOTHING
                """,
                (task_id,),
            )

            cursor.execute(
                """
                SELECT next_seq FROM task_event_seq_counters WHERE task_id = ?
                """,
                (task_id,),
            )
            row = cursor.fetchone()
            if not row:
                raise RuntimeError(f"Failed to get seq counter for task {task_id}")
            next_seq = row[0]

            # Step 2: Insert event with generated seq
            cursor.execute(
                """
                INSERT INTO task_events (
                    task_id, event_type, phase, actor,
                    span_id, parent_span_id, seq, payload, created_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
                """,
                (
                    task_id,
                    event_type,
                    phase,
                    actor,
                    span_id,
                    parent_span_id,
                    next_seq,
                    payload_json,
                ),
            )

            event_id = cursor.lastrowid

            # Step 3: Increment seq counter
            cursor.execute(
                """
                UPDATE task_event_seq_counters
                SET next_seq = next_seq + 1, updated_at = CURRENT_TIMESTAMP
                WHERE task_id = ?
                """,
                (task_id,),
            )

            # Step 4: Retrieve created_at timestamp
            cursor.execute(
                """
                SELECT created_at FROM task_events WHERE event_id = ?
                """,
                (event_id,),
            )
            created_row = cursor.fetchone()
            created_at = created_row[0] if created_row else None

            # Capture results
            result["event_id"] = event_id
            result["seq"] = next_seq
            result["created_at"] = created_at

            conn.commit()

        # Submit transaction via SQLiteWriter (serialized writes)
        try:
            self.writer.submit(_insert_event, timeout=timeout)
        except Exception as e:
            logger.error(f"Failed to emit event for task {task_id}: {e}", exc_info=True)
            raise RuntimeError(f"Failed to emit event: {e}") from e

        # Build and return TaskEvent
        return TaskEvent(
            event_id=result["event_id"],
            task_id=task_id,
            event_type=event_type,
            phase=phase,
            actor=actor,
            span_id=span_id,
            parent_span_id=parent_span_id,
            seq=result["seq"],
            payload=payload,
            created_at=result["created_at"],
        )

    def get_events(
        self,
        task_id: str,
        since_seq: Optional[int] = None,
        limit: int = 100,
    ) -> List[TaskEvent]:
        """
        Get events for a task (ordered by seq)

        Args:
            task_id: Task ID
            since_seq: Optional - Return events with seq > since_seq
            limit: Maximum number of events to return (default: 100)

        Returns:
            List of TaskEvent objects ordered by seq ASC
        """
        from agentos.store import get_db

        conn = get_db()
        cursor = conn.cursor()

        if since_seq is not None:
            query = """
                SELECT * FROM task_events
                WHERE task_id = ? AND seq > ?
                ORDER BY seq ASC
                LIMIT ?
            """
            cursor.execute(query, (task_id, since_seq, limit))
        else:
            query = """
                SELECT * FROM task_events
                WHERE task_id = ?
                ORDER BY seq ASC
                LIMIT ?
            """
            cursor.execute(query, (task_id, limit))

        rows = cursor.fetchall()
        return [TaskEvent.from_row(row) for row in rows]

    def get_latest_events(self, task_id: str, limit: int = 50) -> List[TaskEvent]:
        """
        Get latest N events for a task (ordered by seq DESC)

        Args:
            task_id: Task ID
            limit: Maximum number of events to return (default: 50)

        Returns:
            List of TaskEvent objects ordered by seq DESC
        """
        from agentos.store import get_db

        conn = get_db()
        cursor = conn.cursor()

        query = """
            SELECT * FROM task_events
            WHERE task_id = ?
            ORDER BY seq DESC
            LIMIT ?
        """
        cursor.execute(query, (task_id, limit))

        rows = cursor.fetchall()
        return [TaskEvent.from_row(row) for row in rows]

    def get_events_by_phase(
        self, task_id: str, phase: str, limit: int = 100
    ) -> List[TaskEvent]:
        """
        Get events for a specific phase

        Args:
            task_id: Task ID
            phase: Phase name (e.g., 'planning', 'executing')
            limit: Maximum number of events to return (default: 100)

        Returns:
            List of TaskEvent objects ordered by seq ASC
        """
        from agentos.store import get_db

        conn = get_db()
        cursor = conn.cursor()

        query = """
            SELECT * FROM task_events
            WHERE task_id = ? AND phase = ?
            ORDER BY seq ASC
            LIMIT ?
        """
        cursor.execute(query, (task_id, phase, limit))

        rows = cursor.fetchall()
        return [TaskEvent.from_row(row) for row in rows]

    def get_checkpoint_events(self, task_id: str) -> List[TaskEvent]:
        """
        Get all checkpoint-related events for a task

        Args:
            task_id: Task ID

        Returns:
            List of TaskEvent objects with event_type containing 'checkpoint'
        """
        from agentos.store import get_db

        conn = get_db()
        cursor = conn.cursor()

        query = """
            SELECT * FROM task_events
            WHERE task_id = ? AND event_type LIKE '%checkpoint%'
            ORDER BY seq ASC
        """
        cursor.execute(query, (task_id,))

        rows = cursor.fetchall()
        return [TaskEvent.from_row(row) for row in rows]

    def get_span_tree(self, task_id: str) -> List[TaskEvent]:
        """
        Get all events for a task with span hierarchy (for graph rendering)

        Returns events ordered by seq, with span relationships intact.

        Args:
            task_id: Task ID

        Returns:
            List of TaskEvent objects ordered by seq ASC
        """
        from agentos.store import get_db

        conn = get_db()
        cursor = conn.cursor()

        # Simple approach: Return all events, client can build tree
        query = """
            SELECT * FROM task_events
            WHERE task_id = ?
            ORDER BY seq ASC
        """
        cursor.execute(query, (task_id,))

        rows = cursor.fetchall()
        return [TaskEvent.from_row(row) for row in rows]

    def get_event_count(self, task_id: str) -> int:
        """
        Get total event count for a task

        Args:
            task_id: Task ID

        Returns:
            Total number of events
        """
        from agentos.store import get_db

        conn = get_db()
        cursor = conn.cursor()

        query = """
            SELECT COUNT(*) FROM task_events WHERE task_id = ?
        """
        cursor.execute(query, (task_id,))

        row = cursor.fetchone()
        return row[0] if row else 0

    def delete_events(self, task_id: str, timeout: float = 10.0) -> int:
        """
        Delete all events for a task (cascade on task deletion)

        Args:
            task_id: Task ID
            timeout: Write operation timeout (default: 10.0 seconds)

        Returns:
            Number of events deleted
        """
        deleted_count = {"count": 0}

        def _delete_events(conn):
            cursor = conn.cursor()
            cursor.execute("DELETE FROM task_events WHERE task_id = ?", (task_id,))
            deleted_count["count"] = cursor.rowcount
            conn.commit()

        try:
            self.writer.submit(_delete_events, timeout=timeout)
        except Exception as e:
            logger.error(f"Failed to delete events for task {task_id}: {e}", exc_info=True)
            raise RuntimeError(f"Failed to delete events: {e}") from e

        return deleted_count["count"]


# ============================================
# Convenience Functions for Common Event Types
# ============================================


def emit_runner_spawn(
    task_id: str,
    span_id: str,
    runner_pid: int,
    runner_version: str,
    explanation: str = "Runner process spawned",
) -> TaskEvent:
    """Emit runner spawn event"""
    service = TaskEventService()
    return service.emit_event(
        task_id=task_id,
        event_type="runner_spawn",
        actor="runner",
        span_id=span_id,
        phase=None,
        parent_span_id=None,
        payload={
            "runner_pid": runner_pid,
            "runner_version": runner_version,
            "explanation": explanation,
        },
    )


def emit_phase_enter(
    task_id: str,
    span_id: str,
    phase: str,
    parent_span_id: Optional[str] = None,
    explanation: str = "",
) -> TaskEvent:
    """Emit phase enter event"""
    service = TaskEventService()
    return service.emit_event(
        task_id=task_id,
        event_type="phase_enter",
        actor="runner",
        span_id=span_id,
        phase=phase,
        parent_span_id=parent_span_id,
        payload={
            "explanation": explanation or f"Entered {phase} phase",
        },
    )


def emit_phase_exit(
    task_id: str,
    span_id: str,
    phase: str,
    parent_span_id: Optional[str] = None,
    explanation: str = "",
) -> TaskEvent:
    """Emit phase exit event"""
    service = TaskEventService()
    return service.emit_event(
        task_id=task_id,
        event_type="phase_exit",
        actor="runner",
        span_id=span_id,
        phase=phase,
        parent_span_id=parent_span_id,
        payload={
            "explanation": explanation or f"Exited {phase} phase",
        },
    )


def emit_work_item_start(
    task_id: str,
    span_id: str,
    parent_span_id: str,
    work_item_id: str,
    work_type: str,
    phase: str = "executing",
    explanation: str = "",
) -> TaskEvent:
    """Emit work item start event"""
    service = TaskEventService()
    return service.emit_event(
        task_id=task_id,
        event_type="work_item_start",
        actor="worker",
        span_id=span_id,
        phase=phase,
        parent_span_id=parent_span_id,
        payload={
            "work_item_id": work_item_id,
            "work_type": work_type,
            "explanation": explanation or f"Started work item: {work_type}",
        },
    )


def emit_work_item_complete(
    task_id: str,
    span_id: str,
    parent_span_id: str,
    work_item_id: str,
    work_type: str,
    phase: str = "executing",
    explanation: str = "",
) -> TaskEvent:
    """Emit work item complete event"""
    service = TaskEventService()
    return service.emit_event(
        task_id=task_id,
        event_type="work_item_complete",
        actor="worker",
        span_id=span_id,
        phase=phase,
        parent_span_id=parent_span_id,
        payload={
            "work_item_id": work_item_id,
            "work_type": work_type,
            "explanation": explanation or f"Completed work item: {work_type}",
        },
    )


def emit_checkpoint_commit(
    task_id: str,
    span_id: str,
    checkpoint_id: str,
    checkpoint_type: str,
    phase: str,
    evidence_refs: Optional[Dict[str, Any]] = None,
    explanation: str = "",
) -> TaskEvent:
    """Emit checkpoint commit event"""
    service = TaskEventService()
    return service.emit_event(
        task_id=task_id,
        event_type="checkpoint_commit",
        actor="runner",
        span_id=span_id,
        phase=phase,
        parent_span_id=None,
        payload={
            "checkpoint_id": checkpoint_id,
            "checkpoint_type": checkpoint_type,
            "evidence_refs": evidence_refs or {},
            "explanation": explanation or f"Checkpoint committed: {checkpoint_type}",
        },
    )


def emit_evidence_collected(
    task_id: str,
    span_id: str,
    phase: str,
    evidence_type: str,
    evidence_id: str,
    explanation: str = "",
) -> TaskEvent:
    """Emit evidence collected event"""
    service = TaskEventService()
    return service.emit_event(
        task_id=task_id,
        event_type="evidence_collected",
        actor="runner",
        span_id=span_id,
        phase=phase,
        parent_span_id=None,
        payload={
            "evidence_type": evidence_type,
            "evidence_id": evidence_id,
            "explanation": explanation or f"Evidence collected: {evidence_type}",
        },
    )

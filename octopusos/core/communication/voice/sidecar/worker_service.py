"""Voice Worker gRPC Service - Runs in Python 3.13 sidecar process.

This service handles voice processing (STT, TTS, audio buffering) in a separate
Python 3.13 process to maintain compatibility with libraries like faster-whisper.

Features:
- Bidirectional audio streaming (low latency)
- Buffer protection (10MB limit per session)
- Concurrent session management (max 10 sessions)
- Health monitoring
- Graceful shutdown
"""

import asyncio
import logging
import os
import signal
import time
from typing import AsyncIterator, Dict, Optional

import grpc

# Import generated gRPC stubs (will be generated by scripts/generate_grpc_stubs.sh)
try:
    from . import voice_worker_pb2, voice_worker_pb2_grpc
except ImportError:
    # Fallback for development
    import voice_worker_pb2
    import voice_worker_pb2_grpc

logger = logging.getLogger(__name__)


class VoiceWorkerServicer(voice_worker_pb2_grpc.VoiceWorkerServicer):
    """gRPC service implementation for voice processing."""

    # Resource limits
    MAX_BUFFER_BYTES = 10 * 1024 * 1024  # 10MB per session
    MAX_CONCURRENT_SESSIONS = 10

    def __init__(self):
        """Initialize voice worker service."""
        self.sessions: Dict[str, Dict] = {}
        self.start_time = time.time()
        self.worker_id = f"worker-{os.getpid()}"

        # Lazy-load heavy dependencies
        self._stt_service = None
        self._tts_service = None

        logger.info(f"VoiceWorkerServicer initialized: {self.worker_id}")

    def _get_stt_service(self, provider: str):
        """Lazy-load STT service."""
        if self._stt_service is None:
            if provider == "whisper_local":
                # Import Whisper (requires Python 3.13)
                try:
                    from agentos.core.communication.voice.stt.whisper_local import WhisperLocalSTT
                    self._stt_service = WhisperLocalSTT()
                    logger.info("Loaded WhisperLocalSTT")
                except ImportError as e:
                    logger.error(f"Failed to load Whisper: {e}")
                    raise
            else:
                raise ValueError(f"Unsupported STT provider: {provider}")
        return self._stt_service

    def _get_tts_service(self, provider: str):
        """Lazy-load TTS service."""
        if self._tts_service is None:
            if provider == "openai":
                from agentos.core.communication.voice.tts.openai_provider import OpenAITTSProvider
                self._tts_service = OpenAITTSProvider()
                logger.info("Loaded OpenAITTSProvider")
            elif provider == "mock":
                from agentos.core.communication.voice.tts.mock_provider import MockTTSProvider
                self._tts_service = MockTTSProvider()
                logger.info("Loaded MockTTSProvider")
            else:
                raise ValueError(f"Unsupported TTS provider: {provider}")
        return self._tts_service

    async def CreateSession(
        self,
        request: voice_worker_pb2.CreateSessionRequest,
        context: grpc.aio.ServicerContext
    ) -> voice_worker_pb2.CreateSessionResponse:
        """Create a new voice session."""
        session_id = request.session_id

        # Check concurrent session limit
        if len(self.sessions) >= self.MAX_CONCURRENT_SESSIONS:
            context.set_code(grpc.StatusCode.RESOURCE_EXHAUSTED)
            context.set_details(f"Max concurrent sessions reached: {self.MAX_CONCURRENT_SESSIONS}")
            return voice_worker_pb2.CreateSessionResponse(
                session_id=session_id,
                status="REJECTED"
            )

        # Create session state
        session_state = {
            "session_id": session_id,
            "project_id": request.project_id,
            "stt_provider": request.stt_provider,
            "tts_provider": request.tts_provider if request.HasField("tts_provider") else None,
            "tts_voice_id": request.tts_voice_id if request.HasField("tts_voice_id") else None,
            "tts_speed": request.tts_speed if request.HasField("tts_speed") else 1.0,
            "audio_buffer": bytearray(),
            "created_at": time.time(),
        }

        self.sessions[session_id] = session_state

        logger.info(f"Created session: {session_id} (project={request.project_id}, "
                   f"stt={request.stt_provider}, tts={session_state['tts_provider']})")

        return voice_worker_pb2.CreateSessionResponse(
            session_id=session_id,
            worker_id=self.worker_id,
            buffer_size_bytes=self.MAX_BUFFER_BYTES,
            status="CREATED"
        )

    async def ProcessAudio(
        self,
        request_iterator: AsyncIterator[voice_worker_pb2.AudioChunk],
        context: grpc.aio.ServicerContext
    ) -> AsyncIterator[voice_worker_pb2.AudioEvent]:
        """Process audio stream (bidirectional)."""
        session_id = None
        session_state = None

        try:
            async for chunk in request_iterator:
                # Initialize session on first chunk
                if session_id is None:
                    session_id = chunk.session_id
                    session_state = self.sessions.get(session_id)

                    if not session_state:
                        yield voice_worker_pb2.AudioEvent(
                            event_type="error",
                            session_id=session_id,
                            text="Session not found",
                            timestamp_ms=int(time.time() * 1000)
                        )
                        return

                # Buffer protection
                if len(session_state["audio_buffer"]) + len(chunk.audio_data) > self.MAX_BUFFER_BYTES:
                    yield voice_worker_pb2.AudioEvent(
                        event_type="error",
                        session_id=session_id,
                        text="Buffer limit exceeded",
                        timestamp_ms=int(time.time() * 1000)
                    )
                    return

                # Append to buffer
                session_state["audio_buffer"].extend(chunk.audio_data)

                # Process STT when buffer reaches threshold (e.g., 1 second of audio)
                # 16kHz * 2 bytes (s16le) = 32000 bytes/second
                bytes_per_second = chunk.sample_rate * 2
                if len(session_state["audio_buffer"]) >= bytes_per_second:
                    # Get STT service
                    stt_service = self._get_stt_service(session_state["stt_provider"])

                    # Transcribe audio
                    audio_data = bytes(session_state["audio_buffer"])
                    session_state["audio_buffer"].clear()

                    # Run STT (blocking, but in asyncio executor)
                    loop = asyncio.get_event_loop()
                    transcript = await loop.run_in_executor(
                        None,
                        stt_service.transcribe_audio,
                        audio_data,
                        chunk.sample_rate
                    )

                    # Yield STT result
                    if transcript:
                        yield voice_worker_pb2.AudioEvent(
                            event_type="stt.final",
                            session_id=session_id,
                            text=transcript,
                            timestamp_ms=int(time.time() * 1000)
                        )

        except Exception as e:
            logger.error(f"Error in ProcessAudio: {e}", exc_info=True)
            if session_id:
                yield voice_worker_pb2.AudioEvent(
                    event_type="error",
                    session_id=session_id,
                    text=str(e),
                    timestamp_ms=int(time.time() * 1000)
                )

    async def StopSession(
        self,
        request: voice_worker_pb2.StopSessionRequest,
        context: grpc.aio.ServicerContext
    ) -> voice_worker_pb2.StopSessionResponse:
        """Stop a voice session."""
        session_id = request.session_id
        session_state = self.sessions.get(session_id)

        if not session_state:
            context.set_code(grpc.StatusCode.NOT_FOUND)
            context.set_details(f"Session not found: {session_id}")
            return voice_worker_pb2.StopSessionResponse(
                session_id=session_id,
                status="NOT_FOUND"
            )

        # Flush buffer if not force stop
        flushed_bytes = 0
        if not request.force and len(session_state["audio_buffer"]) > 0:
            flushed_bytes = len(session_state["audio_buffer"])
            # Could process remaining buffer here if needed

        # Remove session
        del self.sessions[session_id]

        logger.info(f"Stopped session: {session_id} (reason={request.reason}, "
                   f"flushed={flushed_bytes} bytes)")

        return voice_worker_pb2.StopSessionResponse(
            session_id=session_id,
            status="STOPPED",
            flushed_bytes=flushed_bytes
        )

    async def HealthCheck(
        self,
        request: voice_worker_pb2.HealthCheckRequest,
        context: grpc.aio.ServicerContext
    ) -> voice_worker_pb2.HealthCheckResponse:
        """Health check endpoint."""
        uptime = int(time.time() - self.start_time)
        active_sessions = len(self.sessions)

        # Calculate memory usage (rough estimate)
        memory_usage = sum(
            len(s["audio_buffer"]) for s in self.sessions.values()
        )

        # Determine health status
        if active_sessions >= self.MAX_CONCURRENT_SESSIONS:
            status = "DEGRADED"
        else:
            status = "OK"

        return voice_worker_pb2.HealthCheckResponse(
            status=status,
            active_sessions=active_sessions,
            memory_usage_bytes=memory_usage,
            uptime_seconds=uptime,
            metrics={
                "worker_id": self.worker_id,
                "max_sessions": str(self.MAX_CONCURRENT_SESSIONS),
            }
        )


async def serve(port: int = 50051):
    """Start gRPC server."""
    server = grpc.aio.server()
    voice_worker_pb2_grpc.add_VoiceWorkerServicer_to_server(
        VoiceWorkerServicer(), server
    )
    server.add_insecure_port(f"[::]:{port}")

    # Graceful shutdown handler
    async def shutdown(sig):
        logger.info(f"Received signal {sig}, shutting down gracefully...")
        await server.stop(grace=5)

    # Register signal handlers
    loop = asyncio.get_event_loop()
    for sig in (signal.SIGTERM, signal.SIGINT):
        loop.add_signal_handler(sig, lambda s=sig: asyncio.create_task(shutdown(s)))

    await server.start()
    logger.info(f"Voice Worker gRPC server started on port {port}")

    await server.wait_for_termination()


if __name__ == "__main__":
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s"
    )
    asyncio.run(serve())

"""
ImprovementProposal Data Models for BrainOS v3

This module defines the data model for improvement proposals generated by BrainOS.
Improvement proposals are the key output for human decision-making about migrating
shadow classifiers to production.

Key Concepts:
- Proposal: A recommendation to modify a classifier based on shadow performance
- Evidence: Statistical data supporting the proposal
- Review State: Lifecycle management for proposal approval/rejection
- Immutability: Once reviewed, proposals cannot be changed
"""

from datetime import datetime, timezone
from enum import Enum
from typing import Any, Dict, List, Optional
from uuid import uuid4

from pydantic import BaseModel, Field, field_validator, model_validator
from agentos.core.time import utc_now



class ChangeType(str, Enum):
    """Type of classifier change being proposed."""
    EXPAND_KEYWORD = "expand_keyword"  # Add new keywords to detection rules
    ADJUST_THRESHOLD = "adjust_threshold"  # Modify confidence thresholds
    ADD_SIGNAL = "add_signal"  # Add new decision signal
    REMOVE_SIGNAL = "remove_signal"  # Remove ineffective signal
    REFINE_RULE = "refine_rule"  # Adjust existing rule weights
    PROMOTE_SHADOW = "promote_shadow"  # Promote entire shadow classifier


class RiskLevel(str, Enum):
    """Risk level of implementing the proposed change."""
    LOW = "LOW"  # Minimal risk, high confidence in improvement
    MEDIUM = "MEDIUM"  # Moderate risk, requires careful testing
    HIGH = "HIGH"  # Significant risk, requires extensive validation


class RecommendationType(str, Enum):
    """Recommendation action for the proposal."""
    PROMOTE = "Promote to v2"  # Promote to production
    REJECT = "Reject"  # Reject proposal
    DEFER = "Defer"  # Defer decision for more data
    TEST = "Test in staging"  # Test in staging environment first


class ProposalStatus(str, Enum):
    """Lifecycle status of improvement proposal."""
    PENDING = "pending"  # Awaiting human review
    ACCEPTED = "accepted"  # Accepted for implementation
    REJECTED = "rejected"  # Rejected, will not implement
    DEFERRED = "deferred"  # Deferred for later review
    IMPLEMENTED = "implemented"  # Accepted and already implemented


class ProposalEvidence(BaseModel):
    """Evidence supporting an improvement proposal.

    Statistical data demonstrating the effectiveness of the proposed change.
    """

    samples: int = Field(
        ge=0,
        description="Number of decision samples in analysis"
    )

    improvement_rate: float = Field(
        description="Improvement rate over active classifier (e.g., +0.18 for +18%)"
    )

    shadow_accuracy: Optional[float] = Field(
        default=None,
        ge=0.0,
        le=1.0,
        description="Shadow classifier accuracy (0.0-1.0)"
    )

    active_accuracy: Optional[float] = Field(
        default=None,
        ge=0.0,
        le=1.0,
        description="Active classifier accuracy (0.0-1.0)"
    )

    error_reduction: Optional[float] = Field(
        default=None,
        description="Error reduction rate (e.g., -0.25 for 25% fewer errors)"
    )

    risk: RiskLevel = Field(
        description="Risk level of implementing this change"
    )

    confidence_score: float = Field(
        default=0.0,
        ge=0.0,
        le=1.0,
        description="Confidence in the evidence (0.0-1.0)"
    )

    time_range_start: Optional[datetime] = Field(
        default=None,
        description="Start of time range for evidence collection"
    )

    time_range_end: Optional[datetime] = Field(
        default=None,
        description="End of time range for evidence collection"
    )

    @field_validator('samples')
    @classmethod
    def validate_samples(cls, v: int) -> int:
        """Ensure samples count is non-negative."""
        if v < 0:
            raise ValueError("samples must be non-negative")
        return v

    @field_validator('shadow_accuracy', 'active_accuracy', 'confidence_score')
    @classmethod
    def validate_percentage(cls, v: Optional[float]) -> Optional[float]:
        """Ensure percentage values are in valid range."""
        if v is not None and not 0.0 <= v <= 1.0:
            raise ValueError("Percentage values must be between 0.0 and 1.0")
        return v

    def to_dict(self) -> Dict[str, Any]:
        """Serialize to dictionary."""
        result = {
            "samples": self.samples,
            "improvement_rate": self.improvement_rate,
            "risk": self.risk.value,
            "confidence_score": self.confidence_score,
        }
        if self.shadow_accuracy is not None:
            result["shadow_accuracy"] = self.shadow_accuracy
        if self.active_accuracy is not None:
            result["active_accuracy"] = self.active_accuracy
        if self.error_reduction is not None:
            result["error_reduction"] = self.error_reduction
        if self.time_range_start is not None:
            result["time_range_start"] = self.time_range_start.isoformat()
        if self.time_range_end is not None:
            result["time_range_end"] = self.time_range_end.isoformat()
        return result

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ProposalEvidence":
        """Deserialize from dictionary."""
        # Parse datetime fields
        if "time_range_start" in data and isinstance(data["time_range_start"], str):
            data["time_range_start"] = datetime.fromisoformat(data["time_range_start"])
        if "time_range_end" in data and isinstance(data["time_range_end"], str):
            data["time_range_end"] = datetime.fromisoformat(data["time_range_end"])

        # Parse enum fields
        if isinstance(data.get("risk"), str):
            data["risk"] = RiskLevel(data["risk"])

        return cls(**data)


class ImprovementProposal(BaseModel):
    """Improvement proposal for classifier modifications.

    Represents a recommendation from BrainOS to modify a classifier based on
    shadow performance analysis. Proposals follow a strict lifecycle:

    - PENDING: Awaiting human review
    - ACCEPTED/REJECTED/DEFERRED: Reviewed by human
    - IMPLEMENTED: Accepted and deployed

    Once reviewed (accepted/rejected/deferred), proposals are immutable.
    """

    # Identifiers
    proposal_id: str = Field(
        default_factory=lambda: f"BP-{uuid4().hex[:6].upper()}",
        description="Unique proposal identifier (e.g., BP-017)"
    )

    # Scope and change details
    scope: str = Field(
        description="Classification scope affected (e.g., 'EXTERNAL_FACT / recency')"
    )

    change_type: ChangeType = Field(
        description="Type of change being proposed"
    )

    description: str = Field(
        description="Human-readable description of the proposed change"
    )

    # Evidence supporting the proposal
    evidence: ProposalEvidence = Field(
        description="Statistical evidence for the proposal"
    )

    # Recommendation
    recommendation: RecommendationType = Field(
        description="Recommended action for this proposal"
    )

    reasoning: str = Field(
        description="Detailed reasoning for the recommendation"
    )

    # Affected components
    affected_version_id: str = Field(
        description="Classifier version ID that would be affected"
    )

    shadow_version_id: Optional[str] = Field(
        default=None,
        description="Shadow classifier version ID (if promoting entire shadow)"
    )

    # Lifecycle management
    status: ProposalStatus = Field(
        default=ProposalStatus.PENDING,
        description="Current status of the proposal"
    )

    created_at: datetime = Field(
        default_factory=utc_now,
        description="When the proposal was created"
    )

    reviewed_by: Optional[str] = Field(
        default=None,
        description="User who reviewed the proposal"
    )

    reviewed_at: Optional[datetime] = Field(
        default=None,
        description="When the proposal was reviewed"
    )

    review_notes: Optional[str] = Field(
        default=None,
        description="Notes from the reviewer"
    )

    implemented_at: Optional[datetime] = Field(
        default=None,
        description="When the proposal was implemented (if accepted)"
    )

    # Metadata
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional metadata"
    )

    @model_validator(mode='after')
    def validate_review_state(self) -> 'ImprovementProposal':
        """Validate review state consistency.

        Ensures reviewed proposals have reviewer and timestamp.
        """
        reviewed_statuses = {
            ProposalStatus.ACCEPTED,
            ProposalStatus.REJECTED,
            ProposalStatus.DEFERRED,
            ProposalStatus.IMPLEMENTED,
        }

        if self.status in reviewed_statuses:
            if not self.reviewed_by:
                raise ValueError(f"Reviewed proposals must have reviewed_by field")
            if not self.reviewed_at:
                raise ValueError(f"Reviewed proposals must have reviewed_at timestamp")

        if self.status == ProposalStatus.IMPLEMENTED:
            if not self.implemented_at:
                raise ValueError("Implemented proposals must have implemented_at timestamp")

        return self

    @field_validator('proposal_id')
    @classmethod
    def validate_proposal_id(cls, v: str) -> str:
        """Ensure proposal_id follows BP-XXXXXX format."""
        if not v.startswith("BP-"):
            raise ValueError("proposal_id must start with 'BP-'")
        return v

    def is_pending(self) -> bool:
        """Check if proposal is pending review."""
        return self.status == ProposalStatus.PENDING

    def is_reviewed(self) -> bool:
        """Check if proposal has been reviewed."""
        return self.status in {
            ProposalStatus.ACCEPTED,
            ProposalStatus.REJECTED,
            ProposalStatus.DEFERRED,
            ProposalStatus.IMPLEMENTED,
        }

    def can_be_modified(self) -> bool:
        """Check if proposal can still be modified.

        Only pending proposals can be modified.
        """
        return self.status == ProposalStatus.PENDING

    def accept(self, reviewed_by: str, notes: Optional[str] = None) -> None:
        """Accept the proposal.

        Args:
            reviewed_by: User accepting the proposal
            notes: Optional review notes

        Raises:
            ValueError: If proposal is not pending
        """
        if not self.can_be_modified():
            raise ValueError(f"Cannot accept proposal in status: {self.status}")

        self.status = ProposalStatus.ACCEPTED
        self.reviewed_by = reviewed_by
        self.reviewed_at = utc_now()
        self.review_notes = notes

    def reject(self, reviewed_by: str, reason: str) -> None:
        """Reject the proposal.

        Args:
            reviewed_by: User rejecting the proposal
            reason: Reason for rejection

        Raises:
            ValueError: If proposal is not pending
        """
        if not self.can_be_modified():
            raise ValueError(f"Cannot reject proposal in status: {self.status}")

        self.status = ProposalStatus.REJECTED
        self.reviewed_by = reviewed_by
        self.reviewed_at = utc_now()
        self.review_notes = reason

    def defer(self, reviewed_by: str, reason: str) -> None:
        """Defer the proposal for later review.

        Args:
            reviewed_by: User deferring the proposal
            reason: Reason for deferring

        Raises:
            ValueError: If proposal is not pending
        """
        if not self.can_be_modified():
            raise ValueError(f"Cannot defer proposal in status: {self.status}")

        self.status = ProposalStatus.DEFERRED
        self.reviewed_by = reviewed_by
        self.reviewed_at = utc_now()
        self.review_notes = reason

    def mark_implemented(self) -> None:
        """Mark proposal as implemented.

        Raises:
            ValueError: If proposal is not accepted
        """
        if self.status != ProposalStatus.ACCEPTED:
            raise ValueError(
                f"Can only mark ACCEPTED proposals as implemented, "
                f"current status: {self.status}"
            )

        self.status = ProposalStatus.IMPLEMENTED
        self.implemented_at = utc_now()

    def to_dict(self) -> Dict[str, Any]:
        """Serialize to dictionary."""
        result = {
            "proposal_id": self.proposal_id,
            "scope": self.scope,
            "change_type": self.change_type.value,
            "description": self.description,
            "evidence": self.evidence.to_dict(),
            "recommendation": self.recommendation.value,
            "reasoning": self.reasoning,
            "affected_version_id": self.affected_version_id,
            "status": self.status.value,
            "created_at": self.created_at.isoformat(),
            "metadata": self.metadata,
        }

        if self.shadow_version_id:
            result["shadow_version_id"] = self.shadow_version_id
        if self.reviewed_by:
            result["reviewed_by"] = self.reviewed_by
        if self.reviewed_at:
            result["reviewed_at"] = self.reviewed_at.isoformat()
        if self.review_notes:
            result["review_notes"] = self.review_notes
        if self.implemented_at:
            result["implemented_at"] = self.implemented_at.isoformat()

        return result

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ImprovementProposal":
        """Deserialize from dictionary."""
        # Parse datetime fields
        if "created_at" in data and isinstance(data["created_at"], str):
            data["created_at"] = datetime.fromisoformat(data["created_at"])
        if "reviewed_at" in data and isinstance(data["reviewed_at"], str):
            data["reviewed_at"] = datetime.fromisoformat(data["reviewed_at"])
        if "implemented_at" in data and isinstance(data["implemented_at"], str):
            data["implemented_at"] = datetime.fromisoformat(data["implemented_at"])

        # Parse enum fields
        if isinstance(data.get("change_type"), str):
            data["change_type"] = ChangeType(data["change_type"])
        if isinstance(data.get("recommendation"), str):
            data["recommendation"] = RecommendationType(data["recommendation"])
        if isinstance(data.get("status"), str):
            data["status"] = ProposalStatus(data["status"])

        # Parse nested evidence
        if isinstance(data.get("evidence"), dict):
            data["evidence"] = ProposalEvidence.from_dict(data["evidence"])

        return cls(**data)

    @classmethod
    def create_keyword_expansion_proposal(
        cls,
        scope: str,
        affected_version_id: str,
        keywords: List[str],
        evidence: ProposalEvidence,
    ) -> "ImprovementProposal":
        """Factory method: Create keyword expansion proposal."""
        return cls(
            scope=scope,
            change_type=ChangeType.EXPAND_KEYWORD,
            description=f"Add keywords to improve detection: {', '.join(keywords)}",
            evidence=evidence,
            recommendation=RecommendationType.PROMOTE if evidence.risk == RiskLevel.LOW
            else RecommendationType.TEST,
            reasoning=f"Shadow classifier shows {evidence.improvement_rate:+.1%} "
                     f"improvement with expanded keyword set",
            affected_version_id=affected_version_id,
        )

    @classmethod
    def create_threshold_adjustment_proposal(
        cls,
        scope: str,
        affected_version_id: str,
        old_threshold: float,
        new_threshold: float,
        evidence: ProposalEvidence,
    ) -> "ImprovementProposal":
        """Factory method: Create threshold adjustment proposal."""
        return cls(
            scope=scope,
            change_type=ChangeType.ADJUST_THRESHOLD,
            description=f"Adjust confidence threshold from {old_threshold:.2f} to {new_threshold:.2f}",
            evidence=evidence,
            recommendation=RecommendationType.PROMOTE if evidence.risk == RiskLevel.LOW
            else RecommendationType.TEST,
            reasoning=f"Threshold adjustment reduces errors by {abs(evidence.error_reduction or 0):.1%}",
            affected_version_id=affected_version_id,
        )

    @classmethod
    def create_shadow_promotion_proposal(
        cls,
        scope: str,
        affected_version_id: str,
        shadow_version_id: str,
        evidence: ProposalEvidence,
    ) -> "ImprovementProposal":
        """Factory method: Create full shadow classifier promotion proposal."""
        return cls(
            scope=scope,
            change_type=ChangeType.PROMOTE_SHADOW,
            description=f"Promote shadow classifier {shadow_version_id} to production",
            evidence=evidence,
            recommendation=RecommendationType.PROMOTE if evidence.risk == RiskLevel.LOW
            else RecommendationType.TEST,
            reasoning=f"Shadow classifier achieves {evidence.improvement_rate:+.1%} "
                     f"improvement over {evidence.samples} samples",
            affected_version_id=affected_version_id,
            shadow_version_id=shadow_version_id,
        )


def validate_proposal_immutability(
    original: ImprovementProposal,
    modified: ImprovementProposal,
) -> None:
    """Validate proposal immutability constraints.

    Ensures reviewed proposals cannot have their core fields modified.

    Args:
        original: Original proposal state
        modified: Modified proposal state

    Raises:
        ValueError: If immutability constraints are violated
    """
    if not original.is_reviewed():
        # Pending proposals can be modified
        return

    # Reviewed proposals are immutable
    immutable_fields = [
        "proposal_id",
        "scope",
        "change_type",
        "description",
        "evidence",
        "recommendation",
        "reasoning",
        "affected_version_id",
        "shadow_version_id",
        "status",
        "reviewed_by",
        "reviewed_at",
        "review_notes",
    ]

    for field in immutable_fields:
        original_value = getattr(original, field)
        modified_value = getattr(modified, field)

        if original_value != modified_value:
            raise ValueError(
                f"Cannot modify field '{field}' on reviewed proposal. "
                f"Original: {original_value}, Modified: {modified_value}"
            )
